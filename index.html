<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Matrix-Eurojackpot-Simulator mit Seed</title>
<style>
body { margin:0; background:black; color:#00ff00; font-family:monospace; overflow:hidden; }
#matrix { position:absolute; top:0; left:0; width:100%; height:100%; z-index:0; }
/* Terminal-Style Output */
#textContainer {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 1;
  width: 60%;
  max-width: 800px;
  height: 400px;
  padding: 20px;
  background-color: rgba(0,0,0,0.95);
  border-radius: 6px;
  box-shadow: 0 0 20px rgba(0,255,0,0.3);
  overflow-y: auto;
  font-family: 'Courier New', monospace;
  color: #00ff00;
  border: 2px solid #00ff00;
  display: none;
}

#output {
  white-space: pre-wrap;
  font-size: 18px;
  line-height: 1.4em;
}

.cursor {
  display: inline-block;
  width: 2px;
  height: 1em;
  background-color: #00ff00;
  margin-left: 2px;
  vertical-align: bottom;
  animation: blink 0.7s steps(1) infinite;
}

@keyframes blink {
  50% { opacity: 0; }
}

.mainnumbers { display:block; margin-top:25px; }
.euronumbers { display:block; margin-top:2px; }

.spinner { border:5px solid rgba(0,255,255,0.2); border-top:5px solid cyan; border-radius:50%; width:60px; height:60px; animation:spin 1s linear infinite; margin-bottom:10px; }
@keyframes spin { 0% { transform: rotate(0deg);} 100% { transform:rotate(360deg);} }
#startButton { font-size:20px; padding:10px 20px; cursor:pointer; margin-top:10px; }
#seedInput { font-size:18px; padding:5px; width:200px; margin-bottom:10px; }
#controls { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:3; display:flex; flex-direction:column; align-items:center; }
</style>

<!-- Externe Esoterik-Faktoren -->
<script type="module" src="matrixEsotericFactors.js"></script>

</head>
<body>

<canvas id="matrix"></canvas>
<div id="textContainer">
  <div id="output"></div>
</div>

<div id="controls">
  <input type="text" id="seedInput" placeholder="Optionaler Seed">
  <button id="startButton">Start Simulation</button>
</div>

<script type="module">
import { getEsotericSeedComponents } from './matrixEsotericFactors.js';

// --- MATRIX HINTERGRUND ---
const canvas = document.getElementById('matrix');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const fontSize = 16;
const columns = Math.floor(canvas.width / fontSize);
const drops = Array(columns).fill(1);
const chars = '01';
let matrixFrameCount = 0;
const columnsReachedBottom = Array(columns).fill(false);
let matrixWarmupComplete = false;
let warmupSoundInterval = null;

function startWarmupSound(){
  if (!audioCtx) return;
  warmupSoundInterval = setInterval(()=>{
    if (matrixWarmupComplete) return;
    try{ playMatrixTone(300 + Math.random()*200, 0.25, 0.03); }catch(e){ console.warn('warmup sound failed', e); }
  }, 300);
}
function stopWarmupSound(){ if(warmupSoundInterval){ clearInterval(warmupSoundInterval); warmupSoundInterval=null; } }

function drawMatrix(){
  matrixFrameCount++;
  ctx.fillStyle='rgba(0,0,0,0.05)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#00ff00';
  ctx.font=fontSize+'px monospace';
  for(let i=0;i<drops.length;i++){
    const text = chars.charAt(Math.floor(Math.random()*chars.length));
    ctx.fillText(text,i*fontSize,drops[i]*fontSize);
    if(drops[i]*fontSize>canvas.height){
      columnsReachedBottom[i]=true;
      if(Math.random()>0.975){ drops[i]=0; }
    }
    drops[i]++;
  }
  if(!matrixWarmupComplete && columnsReachedBottom.every(Boolean)){
    matrixWarmupComplete = true;
    console.debug('[drawMatrix] matrix warmup: all columns reached bottom');
  }
}

// --- CSV HISTORIE LADEN ---
let history = [];
async function loadCSV(){
  console.debug('[loadCSV] Start loading history.csv');
  const response = await fetch('history.csv');
  const text = await response.text();
  const lines = text.trim().split('\n');
  console.debug('[loadCSV] CSV loaded, total lines:', lines.length);

  const chunkSize=200;
  for(let i=0;i<lines.length;i+=chunkSize){
    const end=Math.min(i+chunkSize,lines.length);
    for(let j=i;j<end;j++){
      const line=lines[j];
      const [date,...nums]=line.split(',');
      const main = nums.slice(0,5).map(s=>Number((s||'').trim()));
      const euro = nums.slice(5,7).map(s=>Number((s||'').trim()));
      const hasAllMain = main.length===5 && main.every(Number.isFinite);
      const hasAllEuro = euro.length===2 && euro.every(Number.isFinite);
      if(!hasAllMain || !hasAllEuro){
        console.warn('[loadCSV] skipped malformed line', j+1, 'content:', line);
        continue;
      }
      history.push({main,euro,date});
    }
    console.debug('[loadCSV] Parsed lines', Math.min(end,lines.length),'of',lines.length);
    await new Promise(resolve=>setTimeout(resolve,0));
  }
  console.debug('[loadCSV] Finished parsing history, history length:', history.length);
}

// --- MATRIX-DETERMINISTISCHE VORHERSAGE MIT SEED UND ESOTERIK ---
async function generateDeterministicNumbers(drawDateStr, history, seedInput){
  console.debug('[generate] start', {drawDateStr, historyLength: history.length, seedProvided: !!seedInput});
  const drawDate = new Date(drawDateStr);
  const year = drawDate.getFullYear();
  const month = drawDate.getMonth()+1;
  const day = drawDate.getDate();
  const weekday = drawDate.getDay();

  let prevSum=0;
  const n = history.length;
  if(n<=500){
    prevSum = history.reduce((sum, draw)=>sum+draw.main.reduce((a,b)=>a+b,0)+draw.euro.reduce((a,b)=>a+b,0),0);
    console.debug('[generate] prevSum computed (direct):', prevSum);
  }else{
    const chunkSize=200;
    for(let i=0;i<n;i+=chunkSize){
      const end=Math.min(i+n, n);
      for(let j=i;j<end;j++){
        const draw=history[j];
        prevSum += draw.main.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0)+draw.euro.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
      }
      console.debug('[generate] processed chunk', Math.min(end,n), 'of', n, 'current prevSum:', prevSum);
      await new Promise(resolve=>setTimeout(resolve,0));
    }
    console.debug('[generate] prevSum computed (chunked):', prevSum);
  }

  const seedNum = seedInput ? seedInput.split('').reduce((acc,c,i)=> acc + (c.charCodeAt(0)*(i+1)*31),0) : 0;
  console.debug('[generate] seedNum =', seedNum);

  // --- Esoterische Faktoren aus matrixEsotericFactors.js ---
  const esoteric = getEsotericSeedComponents(drawDate, seedNum);
  console.debug('[generate] esoteric values:', esoteric);

  const main=[], euro=[];
  function pseudoRandom(seed, range){ let x=Math.sin(seed)*10000; return Math.floor(Math.abs(x)%range)+1; }

  for(let i=0;i<5;i++){
    const seed = year*10000 + month*100 + day + weekday*7 + prevSum + seedNum + esoteric.combined + i*37;
    let num = pseudoRandom(seed,50);
    while(main.includes(num)) num = (num%50)+1;
    main.push(num);
  }
  console.debug('[generate] main numbers generated (pre-sort):', main);

  for(let i=0;i<2;i++){
    const seed = year*10000 + month*100 + day + weekday*3 + prevSum + seedNum + esoteric.combined + i*13;
    let num = pseudoRandom(seed,12);
    while(euro.includes(num)) num = (num%12)+1;
    euro.push(num);
  }
  console.debug('[generate] euro numbers generated (pre-sort):', euro);

  main.sort((a,b)=>a-b);
  euro.sort((a,b)=>a-b);
  return {main, euro, esoteric};
}

// --- Weitere bestehende Funktionen (nextDrawDate, typeOutText, animateNumbers, showNumbersStepByStep, Audio, Start Button) unverÃ¤ndert ---


function nextDrawDate(){
  const now = new Date();
  const drawDays = [2,5]; // Dienstag (2), Freitag (5)

  for (let delta = 0; delta <= 7; delta++) {
    const candidate = new Date(now);
    candidate.setDate(now.getDate() + delta);
    const dow = candidate.getDay();
    if (!drawDays.includes(dow)) continue;

    if (delta === 0) {
      const h = now.getHours();
      const m = now.getMinutes();
      if (h < 21 || (h === 21 && m === 0)) {
        candidate.setHours(21,0,0,0);
        return candidate; // RETURN Date-Objekt
      }
      continue;
    }

    candidate.setHours(21,0,0,0);
    return candidate; // RETURN Date-Objekt
  }

  // fallback Dienstag nÃ¤chster Woche
  const fallback = new Date(now);
  fallback.setDate(now.getDate() + ((9 - now.getDay()) % 7));
  fallback.setHours(21,0,0,0);
  return fallback; // RETURN Date-Objekt
}


// --- TIPPEFFEKT ---
let lastCursor = null;

function typeOutText(element, text, delay = 100, callback){
  let i = 0;
  const lineSpan = document.createElement('span');
  element.appendChild(lineSpan);
  
  if(lastCursor) lastCursor.remove();
  
  const cursorSpan = document.createElement('span');
  cursorSpan.className = 'cursor';
  lineSpan.appendChild(cursorSpan);
  lastCursor = cursorSpan;
  
  function typeChar(){
    if(i < text.length){
      cursorSpan.insertAdjacentText('beforebegin', text[i]);
      i++;
      element.scrollTop = element.scrollHeight; // scroll automatisch nach unten
      setTimeout(typeChar, delay);
    } else {
      if(callback) callback();
    }
  }
  
  typeChar();
}

// --- SIMULATION ANZEIGE ---
function animateNumbers(element, finalNumbers, duration, callback) {
  const startTime = Date.now();
  const interval = 50; // Zeit zwischen den Zufallszahlen
  let intervalId;

  function generateRandomNumbers(count, max) {
    return Array.from({length: count}, () => Math.floor(Math.random() * max) + 1).sort((a,b) => a-b);
  }

  intervalId = setInterval(() => {
    if (Date.now() - startTime >= duration) {
      clearInterval(intervalId);
      element.textContent = finalNumbers.join(", ");
      if (callback) callback();
      return;
    }
    const randomNums = generateRandomNumbers(finalNumbers.length, finalNumbers.length <= 2 ? 12 : 50);
    element.textContent = randomNums.join(", ");
  }, interval);
}

async function showNumbersStepByStep(seedInput){
  const out=document.getElementById('output');
  textContainer.style.display = 'block';
  const drawDate = nextDrawDate();
  const drawDateStr = drawDate.toLocaleString('de-DE', {weekday:'long', day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit'}) + ' Uhr';
  console.debug('[show] before generateDeterministicNumbers, drawDate:', drawDate);
  const nums = await generateDeterministicNumbers(drawDate, history, seedInput);
  console.debug('[show] after generateDeterministicNumbers, nums:', nums);

// === Terminal-Ausgabe der esoterischen Werte ===
const esoteric = nums.esoteric;
out.innerHTML += `<span>===== MATRIX-PROGNOSE: EUROJACKPOT =====\n</span>
<span>âš¡ Kosmische Resonanz: ${(esoteric.moonPhase*100).toFixed(2)}%</span>
<span>ðŸ”¢ Numerologische Schwingung: ${esoteric.numerology}</span>
<span>â™’ Sternzeichen-Code: ${esoteric.zodiacCode}</span>
<span>ðŸŒ€ Planck-Drift: ${esoteric.drift.toFixed(5)}</span>
<span>ðŸ“¡ Schumann-Frequenz: ${esoteric.schumann.toFixed(2)} Hz</span>
<span>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n</span>`;

  setTimeout(()=>{
    typeOutText(out,"# NÃ¤chste Ziehung: "+drawDateStr,50,()=>{
      setTimeout(()=>{
        const mainSpan = document.createElement('span');
        mainSpan.className = 'mainnumbers';
        mainSpan.textContent = "# Hauptzahlen: ";
        out.appendChild(mainSpan);
        const mainNumSpan = document.createElement('span');
        mainSpan.appendChild(mainNumSpan);
        
        // Animiere Hauptzahlen
        animateNumbers(mainNumSpan, nums.main, 2000, () => {
          setTimeout(() => {
            const euroSpan = document.createElement('span');
            euroSpan.className = 'euronumbers';
            euroSpan.textContent = "# Eurozahlen: ";
            out.appendChild(euroSpan);
            const euroNumSpan = document.createElement('span');
            euroSpan.appendChild(euroNumSpan);
            
            // Animiere Eurozahlen
            animateNumbers(euroNumSpan, nums.euro, 2000, () => {
              playVictorySound();
              // Entferne alle blinkenden Cursor
              document.querySelectorAll('.cursor').forEach(cursor => cursor.remove());
            });
          }, 500);
        });
      },300);
    });
  },300);
}

// --- AUDIO ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function playMatrixTone(f,d,gain=0.1){
  const osc=audioCtx.createOscillator();
  const amp=audioCtx.createGain();
  osc.type='sine';
  osc.frequency.setValueAtTime(f,audioCtx.currentTime);
  amp.gain.setValueAtTime(gain,audioCtx.currentTime);
  osc.connect(amp).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime+d);
}
function playMatrixTheme(){
  playMatrixTone(100,3,0.08);
  setTimeout(()=>playMatrixTone(110,12,0.07),500);
  [400,450,500,550,600].forEach((f,i)=>setTimeout(()=>playMatrixTone(f,0.15,0.05),i*400));
}
function playVictorySound(){
  const osc=audioCtx.createOscillator();
  const gain=audioCtx.createGain();
  osc.type='triangle';
  osc.frequency.setValueAtTime(600,audioCtx.currentTime);
  gain.gain.setValueAtTime(0.2,audioCtx.currentTime);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.frequency.exponentialRampToValueAtTime(1200,audioCtx.currentTime+1);
  osc.stop(audioCtx.currentTime+1);
}

// --- START BUTTON ---
document.getElementById('startButton').addEventListener('click',async ()=>{
  const seedInput = document.getElementById('seedInput').value;
  audioCtx=new AudioContext();
  console.debug('[start] Clicked start, seedInput:', seedInput);
  // Hide controls immediately so UI is clean while loading
  document.getElementById('controls').style.display='none';
  // Ensure the centered text container is visible and previous output cleared
  const textContainer = document.getElementById('textContainer');
  const out = document.getElementById('output');
  if (out) { out.textContent = ''; }
  await loadCSV(); // CSV laden
  console.debug('[start] CSV loaded, history length:', history.length);
  // Start matrix rain first and wait until it has warmed up before showing text
  const matrixInterval = setInterval(drawMatrix,50);
  console.debug('[start] matrix rain started, waiting for warmup...');
  // wait until the matrix rain has filled the screen (all columns reached bottom once)
  // Start warmup sound loop while waiting
  startWarmupSound();
  await new Promise(resolve => {
    const maxWait = 5000; // safety timeout
    const start = Date.now();
    const check = setInterval(() => {
      if (matrixWarmupComplete || Date.now() - start > maxWait) {
        clearInterval(check);
        console.debug('[start] matrix warmup complete (or timeout). frames:', matrixFrameCount, 'warmup:', matrixWarmupComplete);
        // stop the warmup sound once warmup is done or timed out
        stopWarmupSound();
        resolve();
      }
    }, 100);
  });
  try {
    await showNumbersStepByStep(seedInput);
    console.debug('[start] showNumbersStepByStep completed');
  } catch (err) {
    console.error('[start] Error during showNumbersStepByStep:', err);
    throw err;
  }
  playMatrixTheme();
  document.getElementById('controls').style.display='none';
});
</script>
</body>
</html>
