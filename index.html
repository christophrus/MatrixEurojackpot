<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Matrix-Eurojackpot-Simulator mit Seed</title>
<style>
body { margin:0; background:black; color:#00ff00; font-family:monospace; overflow:hidden; }
#matrix { position:absolute; top:0; left:0; width:100%; height:100%; z-index:0; }
#output { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:1; white-space:pre; font-size:24px; text-align:center; color:cyan; }
.numbers { display:block; margin:10px 0; font-size:32px; font-weight:bold; color:cyan; }
#loading { position:absolute; top:35%; left:50%; transform:translate(-50%,-50%); z-index:2; display:flex; flex-direction:column; align-items:center; color:cyan; }
.spinner { border:5px solid rgba(0,255,255,0.2); border-top:5px solid cyan; border-radius:50%; width:60px; height:60px; animation:spin 1s linear infinite; margin-bottom:10px; }
@keyframes spin { 0% { transform: rotate(0deg);} 100% { transform:rotate(360deg);} }
#startButton { font-size:20px; padding:10px 20px; cursor:pointer; margin-top:10px; }
#seedInput { font-size:18px; padding:5px; width:200px; margin-bottom:10px; }
.cursor { display:inline-block; width:10px; animation:blink 0.7s steps(1) infinite; }
@keyframes blink { 50% { opacity:0; } }
#controls { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:3; display:flex; flex-direction:column; align-items:center; }
</style>
</head>
<body>

<canvas id="matrix"></canvas>
<div id="output"></div>
<div id="loading" style="display:none;">
  <div class="spinner"></div>
  <div>Berechne Zahlen...</div>
</div>

<div id="controls">
  <input type="text" id="seedInput" placeholder="Optionaler Seed">
  <button id="startButton">Start Simulation</button>
</div>

<script>
// --- MATRIX HINTERGRUND ---
const canvas = document.getElementById('matrix');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const fontSize = 16;
const columns = Math.floor(canvas.width / fontSize);
const drops = Array(columns).fill(1);
const chars = '01';
function drawMatrix(){
  ctx.fillStyle='rgba(0,0,0,0.05)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#00ff00';
  ctx.font=fontSize+'px monospace';
  for(let i=0;i<drops.length;i++){
    const text = chars.charAt(Math.floor(Math.random()*chars.length));
    ctx.fillText(text,i*fontSize,drops[i]*fontSize);
    if(drops[i]*fontSize>canvas.height && Math.random()>0.975){drops[i]=0;}
    drops[i]++;
  }
}

// --- CSV HISTORIE LADEN ---
let history = [];
async function loadCSV() {
  console.debug('[loadCSV] Start loading history.csv');
  const response = await fetch('history.csv');
  const text = await response.text();
  const lines = text.trim().split('\n');
  console.debug('[loadCSV] CSV loaded, total lines:', lines.length);

  // Chunked parsing to avoid blocking the UI for large files
  const chunkSize = 200;
  for (let i = 0; i < lines.length; i += chunkSize) {
    const end = Math.min(i + chunkSize, lines.length);
    for (let j = i; j < end; j++) {
      const line = lines[j];
      const [date, ...nums] = line.split(',');
      // defensives Parsen: trim und Number, prüfe auf NaN
      const main = nums.slice(0,5).map(s => {
        const v = Number((s||'').trim());
        return Number.isFinite(v) ? v : NaN;
      });
      const euro = nums.slice(5,7).map(s => {
        const v = Number((s||'').trim());
        return Number.isFinite(v) ? v : NaN;
      });
      // Prüfe, ob die erwarteten Werte vorhanden sind
      const hasAllMain = main.length === 5 && main.every(Number.isFinite);
      const hasAllEuro = euro.length === 2 && euro.every(Number.isFinite);
      if (!hasAllMain || !hasAllEuro) {
        console.warn('[loadCSV] skipped malformed line', j + 1, 'content:', line);
        continue; // skip malformed line
      }
      history.push({main,euro,date});
    }
    console.debug('[loadCSV] Parsed lines', Math.min(end, lines.length), 'of', lines.length);
    // yield to the event loop so the UI stays responsive
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  console.debug('[loadCSV] Finished parsing history, history length:', history.length);
}

// --- MATRIX-DETERMINISTISCHE VORHERSAGE MIT SEED ---
// Diese Version nutzt ALLE historischen Einträge aus `history`.
// Für sehr große CSVs wird die Summenberechnung in Chunks ausgeführt
// (mit kurzen Pausen) damit der Browser nicht einfriert.
async function generateDeterministicNumbers(drawDateStr, history, seedInput) {
  console.debug('[generate] start', { drawDateStr, historyLength: history.length, seedProvided: !!seedInput });
  const drawDate = new Date(drawDateStr);
  const year = drawDate.getFullYear();
  const month = drawDate.getMonth() + 1;
  const day = drawDate.getDate();
  const weekday = drawDate.getDay();

  // Berechne die Summe aller bisherigen Ziehungen asynchron in Chunks
  let prevSum = 0;
  const n = history.length;
  console.debug('[generate] history length =', n);
  // Wenn history moderat groß ist, mache eine direkte Reduktion (schnell)
  if (n <= 500) {
    prevSum = history.reduce((sum, draw) => sum + draw.main.reduce((a,b)=>a+b,0) + draw.euro.reduce((a,b)=>a+b,0), 0);
    console.debug('[generate] prevSum computed (direct):', prevSum);
  } else {
    // Chunking für große Arrays: verarbeite z.B. 200 Einträge, dann yield
    const chunkSize = 200;
    for (let i = 0; i < n; i += chunkSize) {
      const end = Math.min(i + chunkSize, n);
      for (let j = i; j < end; j++) {
        const draw = history[j];
        // sichere Summierung: ignoriere nicht-finite Werte (falls doch vorhanden)
        const mainSum = (draw.main || []).reduce((a,b) => a + (Number.isFinite(b) ? b : 0), 0);
        const euroSum = (draw.euro || []).reduce((a,b) => a + (Number.isFinite(b) ? b : 0), 0);
        prevSum += mainSum + euroSum;
        // Falls irgendwas ungewöhnlich ist, logge die Zeile zur Untersuchung
        if (!Array.isArray(draw.main) || !Array.isArray(draw.euro) || draw.main.length !==5 || draw.euro.length !==2) {
          console.warn('[generate] unexpected draw format at index', j, draw);
        }
      }
      console.debug('[generate] processed chunk', Math.min(end, n), 'of', n, 'current prevSum:', prevSum);
      // Kurz pausieren, damit der UI-Thread Events verarbeiten kann
      // (wichtig bei ~900 Einträgen oder mehr)
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    console.debug('[generate] prevSum computed (chunked):', prevSum);
  }

  // Verbesserte Seed-Berechnung die die Position der Zeichen berücksichtigt
  const seedNum = seedInput ? seedInput.split('').reduce((acc, c, i) => {
    // Verwende Position (i+1) als Multiplikator und addiere eine Primzahl pro Position
    return acc + (c.charCodeAt(0) * (i + 1) * 31);
  }, 0) : 0;
  console.debug('[generate] seedNum =', seedNum);

  const main = [];
  const euro = [];

  function pseudoRandom(seed, range) {
    let x = Math.sin(seed) * 10000;
    return Math.floor(Math.abs(x) % range) + 1;
  }

  for(let i=0; i<5; i++){
    const seed = year*10000 + month*100 + day + weekday*7 + prevSum + seedNum + i*37;
    let num = pseudoRandom(seed,50);
    while(main.includes(num)) num = (num % 50) + 1;
    main.push(num);
  }
  console.debug('[generate] main numbers generated (pre-sort):', main);

  for(let i=0; i<2; i++){
    const seed = year*10000 + month*100 + day + weekday*3 + prevSum + seedNum + i*13;
    let num = pseudoRandom(seed,12);
    while(euro.includes(num)) num = (num % 12) + 1;
    euro.push(num);
  }
  console.debug('[generate] euro numbers generated (pre-sort):', euro);

  main.sort((a,b)=>a-b);
  euro.sort((a,b)=>a-b);
  return {main,euro};
}

// --- NÄCHSTES ZIEHUNGSDATUM ---
function nextDrawDate(){
  const today = new Date();
  const dayOfWeek = today.getDay();
  const drawDays = [2,5]; // Dienstag, Freitag
  let diffs = drawDays.map(d=>((d-dayOfWeek+7)%7));
  diffs.sort((a,b)=>a-b);
  let nextDiff = diffs[0];
  if(drawDays.includes(dayOfWeek) && today.getHours()<21){nextDiff=0;}
  const nextDraw = new Date(today);
  nextDraw.setDate(today.getDate()+nextDiff);
  nextDraw.setHours(21,0,0,0);
  return nextDraw.toLocaleString('de-DE',{weekday:'long', day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit'});
}

// --- TIPPEFFEKT ---
let lastCursor=null;
function typeOutText(element,text,delay=150,callback){
  let i=0;
  const lineSpan = document.createElement('span');
  lineSpan.className='numbers';
  element.appendChild(lineSpan);
  if(lastCursor) lastCursor.remove();
  const cursorSpan=document.createElement('span');
  cursorSpan.className='cursor';
  cursorSpan.textContent='_';
  lineSpan.appendChild(cursorSpan);
  lastCursor = cursorSpan;
  function typeChar(){
    if(i<text.length){
      cursorSpan.insertAdjacentText('beforebegin',text[i]);
      i++;
      setTimeout(typeChar,delay);
    }else{ if(callback) callback(); }
  }
  typeChar();
}

// --- SIMULATION ANZEIGE ---
function animateNumbers(element, finalNumbers, duration, callback) {
  const startTime = Date.now();
  const interval = 50; // Zeit zwischen den Zufallszahlen
  let intervalId;

  function generateRandomNumbers(count, max) {
    return Array.from({length: count}, () => Math.floor(Math.random() * max) + 1).sort((a,b) => a-b);
  }

  intervalId = setInterval(() => {
    if (Date.now() - startTime >= duration) {
      clearInterval(intervalId);
      element.textContent = finalNumbers.join(", ");
      if (callback) callback();
      return;
    }
    const randomNums = generateRandomNumbers(finalNumbers.length, finalNumbers.length <= 2 ? 12 : 50);
    element.textContent = randomNums.join(", ");
  }, interval);
}

async function showNumbersStepByStep(seedInput){
  const out=document.getElementById('output');
  const loading=document.getElementById('loading');
  loading.style.display='flex';
  const drawDateStr=nextDrawDate();
  console.debug('[show] before generateDeterministicNumbers, drawDateStr:', drawDateStr);
  const nums = await generateDeterministicNumbers(drawDateStr, history, seedInput);
  console.debug('[show] after generateDeterministicNumbers, nums:', nums);

  setTimeout(()=>{
    typeOutText(out,"===== MATRIX-PROGNOSE: EUROJACKPOT =====",50,()=>{
      setTimeout(()=>{
        typeOutText(out,"Nächste Ziehung: "+drawDateStr,50,()=>{
          setTimeout(()=>{
            const mainSpan = document.createElement('span');
            mainSpan.className = 'numbers';
            mainSpan.textContent = "Hauptzahlen: ";
            out.appendChild(mainSpan);
            const mainNumSpan = document.createElement('span');
            mainSpan.appendChild(mainNumSpan);
            
            // Animiere Hauptzahlen
            animateNumbers(mainNumSpan, nums.main, 2000, () => {
              setTimeout(() => {
                const euroSpan = document.createElement('span');
                euroSpan.className = 'numbers';
                euroSpan.textContent = "Eurozahlen: ";
                out.appendChild(euroSpan);
                const euroNumSpan = document.createElement('span');
                euroSpan.appendChild(euroNumSpan);
                
                // Animiere Eurozahlen
                animateNumbers(euroNumSpan, nums.euro, 2000, () => {
                  loading.style.display='none';
                  playVictorySound();
                  // Entferne alle blinkenden Cursor
                  document.querySelectorAll('.cursor').forEach(cursor => cursor.remove());
                });
              }, 500);
            });
          },300);
        });
      },300);
    });
  },1500);
}

// --- AUDIO ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function playMatrixTone(f,d,gain=0.1){
  const osc=audioCtx.createOscillator();
  const amp=audioCtx.createGain();
  osc.type='sine';
  osc.frequency.setValueAtTime(f,audioCtx.currentTime);
  amp.gain.setValueAtTime(gain,audioCtx.currentTime);
  osc.connect(amp).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime+d);
}
function playMatrixTheme(){
  playMatrixTone(100,3,0.08);
  setTimeout(()=>playMatrixTone(110,2.5,0.07),500);
  [400,450,500,550,600].forEach((f,i)=>setTimeout(()=>playMatrixTone(f,0.15,0.05),i*400));
}
function playVictorySound(){
  const osc=audioCtx.createOscillator();
  const gain=audioCtx.createGain();
  osc.type='triangle';
  osc.frequency.setValueAtTime(600,audioCtx.currentTime);
  gain.gain.setValueAtTime(0.2,audioCtx.currentTime);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.frequency.exponentialRampToValueAtTime(1200,audioCtx.currentTime+1);
  osc.stop(audioCtx.currentTime+1);
}

// --- START BUTTON ---
document.getElementById('startButton').addEventListener('click',async ()=>{
  const seedInput = document.getElementById('seedInput').value;
  audioCtx=new AudioContext();
  console.debug('[start] Clicked start, seedInput:', seedInput);
  await loadCSV(); // CSV laden
  console.debug('[start] CSV loaded, history length:', history.length);
  setInterval(drawMatrix,50);
  try {
    await showNumbersStepByStep(seedInput);
    console.debug('[start] showNumbersStepByStep completed');
  } catch (err) {
    console.error('[start] Error during showNumbersStepByStep:', err);
    throw err;
  }
  playMatrixTheme();
  document.getElementById('controls').style.display='none';
});
</script>
</body>
</html>
