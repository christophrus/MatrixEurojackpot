<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Matrix-Eurojackpot-Simulator mit Seed</title>
<style>
body { margin:0; background:black; color:#00ff00; font-family:monospace; overflow:hidden; }
#matrix { position:absolute; top:0; left:0; width:100%; height:100%; z-index:0; }
/* Centered white semi-transparent box that holds the output text. */
#textContainer { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:1; width:50%; box-sizing:border-box; padding:18px; border-radius:6px; display:none; }
/* The actual output inside the centered box - left aligned but the box itself is centered on screen */
#output { white-space:pre-wrap; font-size:24px; text-align:left; color:cyan; }
.numbers { display:block; margin:10px 0; font-size:32px; font-weight:bold; color:cyan; }
#loading { position:absolute; top:35%; left:50%; transform:translate(-50%,-50%); z-index:2; display:flex; flex-direction:column; align-items:center; color:cyan; }
.spinner { border:5px solid rgba(0,255,255,0.2); border-top:5px solid cyan; border-radius:50%; width:60px; height:60px; animation:spin 1s linear infinite; margin-bottom:10px; }
@keyframes spin { 0% { transform: rotate(0deg);} 100% { transform:rotate(360deg);} }
#startButton { font-size:20px; padding:10px 20px; cursor:pointer; margin-top:10px; }
#seedInput { font-size:18px; padding:5px; width:200px; margin-bottom:10px; }
.cursor { display:inline-block; width:10px; animation:blink 0.7s steps(1) infinite; }
@keyframes blink { 50% { opacity:0; } }
#controls { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:3; display:flex; flex-direction:column; align-items:center; }
</style>
</head>
<body>

<canvas id="matrix"></canvas>
<div id="textContainer">
  <div id="output"></div>
</div>
<div id="loading" style="display:none;">
  <div class="spinner"></div>
  <div>Berechne Zahlen...</div>
</div>

<div id="controls">
  <input type="text" id="seedInput" placeholder="Optionaler Seed">
  <button id="startButton">Start Simulation</button>
</div>

<script>
// --- MATRIX HINTERGRUND ---
const canvas = document.getElementById('matrix');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const fontSize = 16;
const columns = Math.floor(canvas.width / fontSize);
const drops = Array(columns).fill(1);
const chars = '01';
let matrixFrameCount = 0; // number of drawMatrix frames executed (used to detect warmup)
// Track which columns have reached the bottom at least once
const columnsReachedBottom = Array(columns).fill(false);
let matrixWarmupComplete = false; // becomes true when all columns reached bottom
// Warmup sound controller
let warmupSoundInterval = null;
function startWarmupSound(){
  if (!audioCtx) return;
  // play a soft repeating tone until warmup completes
  warmupSoundInterval = setInterval(()=>{
    if (matrixWarmupComplete) return; // stop scheduling new tones
    try{
      // gentle descending tones
      playMatrixTone(300 + Math.random()*200, 0.25, 0.03);
    }catch(e){ console.warn('warmup sound failed', e); }
  }, 300);
}
function stopWarmupSound(){
  if (warmupSoundInterval) { clearInterval(warmupSoundInterval); warmupSoundInterval = null; }
}
function drawMatrix(){
  matrixFrameCount++;
  ctx.fillStyle='rgba(0,0,0,0.05)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#00ff00';
  ctx.font=fontSize+'px monospace';
  for(let i=0;i<drops.length;i++){
    const text = chars.charAt(Math.floor(Math.random()*chars.length));
    ctx.fillText(text,i*fontSize,drops[i]*fontSize);
    if(drops[i]*fontSize>canvas.height){
      // mark this column as having reached the bottom
      columnsReachedBottom[i] = true;
      // small random chance to reset so the effect continues
      if (Math.random() > 0.975) { drops[i] = 0; }
    }
    drops[i]++;
  }
  // once every column reached bottom at least once, mark warmup complete
  if (!matrixWarmupComplete && columnsReachedBottom.every(Boolean)) {
    matrixWarmupComplete = true;
    console.debug('[drawMatrix] matrix warmup: all columns reached bottom');
  }
}

// --- CSV HISTORIE LADEN ---
let history = [];
async function loadCSV() {
  console.debug('[loadCSV] Start loading history.csv');
  const response = await fetch('history.csv');
  const text = await response.text();
  const lines = text.trim().split('\n');
  console.debug('[loadCSV] CSV loaded, total lines:', lines.length);

  // Chunked parsing to avoid blocking the UI for large files
  const chunkSize = 200;
  for (let i = 0; i < lines.length; i += chunkSize) {
    const end = Math.min(i + chunkSize, lines.length);
    for (let j = i; j < end; j++) {
      const line = lines[j];
      const [date, ...nums] = line.split(',');
      // defensives Parsen: trim und Number, prüfe auf NaN
      const main = nums.slice(0,5).map(s => {
        const v = Number((s||'').trim());
        return Number.isFinite(v) ? v : NaN;
      });
      const euro = nums.slice(5,7).map(s => {
        const v = Number((s||'').trim());
        return Number.isFinite(v) ? v : NaN;
      });
      // Prüfe, ob die erwarteten Werte vorhanden sind
      const hasAllMain = main.length === 5 && main.every(Number.isFinite);
      const hasAllEuro = euro.length === 2 && euro.every(Number.isFinite);
      if (!hasAllMain || !hasAllEuro) {
        console.warn('[loadCSV] skipped malformed line', j + 1, 'content:', line);
        continue; // skip malformed line
      }
      history.push({main,euro,date});
    }
    console.debug('[loadCSV] Parsed lines', Math.min(end, lines.length), 'of', lines.length);
    // yield to the event loop so the UI stays responsive
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  console.debug('[loadCSV] Finished parsing history, history length:', history.length);
}

// --- MATRIX-DETERMINISTISCHE VORHERSAGE MIT SEED ---
// Diese Version nutzt ALLE historischen Einträge aus `history`.
// Für sehr große CSVs wird die Summenberechnung in Chunks ausgeführt
// (mit kurzen Pausen) damit der Browser nicht einfriert.
async function generateDeterministicNumbers(drawDateStr, history, seedInput) {
  console.debug('[generate] start', { drawDateStr, historyLength: history.length, seedProvided: !!seedInput });
  const drawDate = new Date(drawDateStr);
  const year = drawDate.getFullYear();
  const month = drawDate.getMonth() + 1;
  const day = drawDate.getDate();
  const weekday = drawDate.getDay();

  // Berechne die Summe aller bisherigen Ziehungen asynchron in Chunks
  let prevSum = 0;
  const n = history.length;
  console.debug('[generate] history length =', n);
  // Wenn history moderat groß ist, mache eine direkte Reduktion (schnell)
  if (n <= 500) {
    prevSum = history.reduce((sum, draw) => sum + draw.main.reduce((a,b)=>a+b,0) + draw.euro.reduce((a,b)=>a+b,0), 0);
    console.debug('[generate] prevSum computed (direct):', prevSum);
  } else {
    // Chunking für große Arrays: verarbeite z.B. 200 Einträge, dann yield
    const chunkSize = 200;
    for (let i = 0; i < n; i += chunkSize) {
      const end = Math.min(i + chunkSize, n);
      for (let j = i; j < end; j++) {
        const draw = history[j];
        // sichere Summierung: ignoriere nicht-finite Werte (falls doch vorhanden)
        const mainSum = (draw.main || []).reduce((a,b) => a + (Number.isFinite(b) ? b : 0), 0);
        const euroSum = (draw.euro || []).reduce((a,b) => a + (Number.isFinite(b) ? b : 0), 0);
        prevSum += mainSum + euroSum;
        // Falls irgendwas ungewöhnlich ist, logge die Zeile zur Untersuchung
        if (!Array.isArray(draw.main) || !Array.isArray(draw.euro) || draw.main.length !==5 || draw.euro.length !==2) {
          console.warn('[generate] unexpected draw format at index', j, draw);
        }
      }
      console.debug('[generate] processed chunk', Math.min(end, n), 'of', n, 'current prevSum:', prevSum);
      // Kurz pausieren, damit der UI-Thread Events verarbeiten kann
      // (wichtig bei ~900 Einträgen oder mehr)
      await new Promise(resolve => setTimeout(resolve, 0));
    }
    console.debug('[generate] prevSum computed (chunked):', prevSum);
  }

  // Verbesserte Seed-Berechnung die die Position der Zeichen berücksichtigt
  const seedNum = seedInput ? seedInput.split('').reduce((acc, c, i) => {
    // Verwende Position (i+1) als Multiplikator und addiere eine Primzahl pro Position
    return acc + (c.charCodeAt(0) * (i + 1) * 31);
  }, 0) : 0;
  console.debug('[generate] seedNum =', seedNum);

  const main = [];
  const euro = [];

  function pseudoRandom(seed, range) {
    let x = Math.sin(seed) * 10000;
    return Math.floor(Math.abs(x) % range) + 1;
  }

  for(let i=0; i<5; i++){
    const seed = year*10000 + month*100 + day + weekday*7 + prevSum + seedNum + i*37;
    let num = pseudoRandom(seed,50);
    while(main.includes(num)) num = (num % 50) + 1;
    main.push(num);
  }
  console.debug('[generate] main numbers generated (pre-sort):', main);

  for(let i=0; i<2; i++){
    const seed = year*10000 + month*100 + day + weekday*3 + prevSum + seedNum + i*13;
    let num = pseudoRandom(seed,12);
    while(euro.includes(num)) num = (num % 12) + 1;
    euro.push(num);
  }
  console.debug('[generate] euro numbers generated (pre-sort):', euro);

  main.sort((a,b)=>a-b);
  euro.sort((a,b)=>a-b);
  return {main,euro};
}

function nextDrawDate(){
  const now = new Date();
  const drawDays = [2,5]; // Dienstag (2), Freitag (5)

  for (let delta = 0; delta <= 7; delta++) {
    const candidate = new Date(now);
    candidate.setDate(now.getDate() + delta);
    const dow = candidate.getDay();
    if (!drawDays.includes(dow)) continue;

    if (delta === 0) {
      const h = now.getHours();
      const m = now.getMinutes();
      if (h < 21 || (h === 21 && m === 0)) {
        candidate.setHours(21,0,0,0);
        return candidate; // RETURN Date-Objekt
      }
      continue;
    }

    candidate.setHours(21,0,0,0);
    return candidate; // RETURN Date-Objekt
  }

  // fallback Dienstag nächster Woche
  const fallback = new Date(now);
  fallback.setDate(now.getDate() + ((9 - now.getDay()) % 7));
  fallback.setHours(21,0,0,0);
  return fallback; // RETURN Date-Objekt
}


// --- TIPPEFFEKT ---
let lastCursor=null;
function typeOutText(element,text,delay=150,callback){
  let i=0;
  const lineSpan = document.createElement('span');
  lineSpan.className='numbers';
  element.appendChild(lineSpan);
  if(lastCursor) lastCursor.remove();
  const cursorSpan=document.createElement('span');
  cursorSpan.className='cursor';
  cursorSpan.textContent='_';
  lineSpan.appendChild(cursorSpan);
  lastCursor = cursorSpan;
  function typeChar(){
    if(i<text.length){
      cursorSpan.insertAdjacentText('beforebegin',text[i]);
      i++;
      setTimeout(typeChar,delay);
    }else{ if(callback) callback(); }
  }
  typeChar();
}

// --- SIMULATION ANZEIGE ---
function animateNumbers(element, finalNumbers, duration, callback) {
  const startTime = Date.now();
  const interval = 50; // Zeit zwischen den Zufallszahlen
  let intervalId;

  function generateRandomNumbers(count, max) {
    return Array.from({length: count}, () => Math.floor(Math.random() * max) + 1).sort((a,b) => a-b);
  }

  intervalId = setInterval(() => {
    if (Date.now() - startTime >= duration) {
      clearInterval(intervalId);
      element.textContent = finalNumbers.join(", ");
      if (callback) callback();
      return;
    }
    const randomNums = generateRandomNumbers(finalNumbers.length, finalNumbers.length <= 2 ? 12 : 50);
    element.textContent = randomNums.join(", ");
  }, interval);
}

async function showNumbersStepByStep(seedInput){
  const out=document.getElementById('output');
  const loading=document.getElementById('loading');
  loading.style.display='flex';
  const drawDate = nextDrawDate();
  const drawDateStr = drawDate.toLocaleString('de-DE', {weekday:'long', day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit'});
  console.debug('[show] before generateDeterministicNumbers, drawDate:', drawDate);
  const nums = await generateDeterministicNumbers(drawDate, history, seedInput);
  console.debug('[show] after generateDeterministicNumbers, nums:', nums);

  setTimeout(()=>{
    typeOutText(out,"===== MATRIX-PROGNOSE: EUROJACKPOT =====",50,()=>{
      setTimeout(()=>{
        typeOutText(out,"Nächste Ziehung: "+drawDateStr,50,()=>{
          setTimeout(()=>{
            const mainSpan = document.createElement('span');
            mainSpan.className = 'numbers';
            mainSpan.textContent = "Hauptzahlen: ";
            out.appendChild(mainSpan);
            const mainNumSpan = document.createElement('span');
            mainSpan.appendChild(mainNumSpan);
            
            // Animiere Hauptzahlen
            animateNumbers(mainNumSpan, nums.main, 2000, () => {
              setTimeout(() => {
                const euroSpan = document.createElement('span');
                euroSpan.className = 'numbers';
                euroSpan.textContent = "Eurozahlen: ";
                out.appendChild(euroSpan);
                const euroNumSpan = document.createElement('span');
                euroSpan.appendChild(euroNumSpan);
                
                // Animiere Eurozahlen
                animateNumbers(euroNumSpan, nums.euro, 2000, () => {
                  loading.style.display='none';
                  playVictorySound();
                  // Entferne alle blinkenden Cursor
                  document.querySelectorAll('.cursor').forEach(cursor => cursor.remove());
                });
              }, 500);
            });
          },300);
        });
      },300);
    });
  },1500);
}

// --- AUDIO ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function playMatrixTone(f,d,gain=0.1){
  const osc=audioCtx.createOscillator();
  const amp=audioCtx.createGain();
  osc.type='sine';
  osc.frequency.setValueAtTime(f,audioCtx.currentTime);
  amp.gain.setValueAtTime(gain,audioCtx.currentTime);
  osc.connect(amp).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime+d);
}
function playMatrixTheme(){
  playMatrixTone(100,3,0.08);
  setTimeout(()=>playMatrixTone(110,12,0.07),500);
  [400,450,500,550,600].forEach((f,i)=>setTimeout(()=>playMatrixTone(f,0.15,0.05),i*400));
}
function playVictorySound(){
  const osc=audioCtx.createOscillator();
  const gain=audioCtx.createGain();
  osc.type='triangle';
  osc.frequency.setValueAtTime(600,audioCtx.currentTime);
  gain.gain.setValueAtTime(0.2,audioCtx.currentTime);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.frequency.exponentialRampToValueAtTime(1200,audioCtx.currentTime+1);
  osc.stop(audioCtx.currentTime+1);
}

// --- START BUTTON ---
document.getElementById('startButton').addEventListener('click',async ()=>{
  const seedInput = document.getElementById('seedInput').value;
  audioCtx=new AudioContext();
  console.debug('[start] Clicked start, seedInput:', seedInput);
  // Hide controls immediately so UI is clean while loading
  document.getElementById('controls').style.display='none';
  // Ensure the centered text container is visible and previous output cleared
  const textContainer = document.getElementById('textContainer');
  const out = document.getElementById('output');
  if (textContainer) { textContainer.style.display = 'block'; }
  if (out) { out.textContent = ''; }
  await loadCSV(); // CSV laden
  console.debug('[start] CSV loaded, history length:', history.length);
  // Start matrix rain first and wait until it has warmed up before showing text
  const matrixInterval = setInterval(drawMatrix,50);
  console.debug('[start] matrix rain started, waiting for warmup...');
  // wait until the matrix rain has filled the screen (all columns reached bottom once)
  // Start warmup sound loop while waiting
  startWarmupSound();
  await new Promise(resolve => {
    const maxWait = 5000; // safety timeout
    const start = Date.now();
    const check = setInterval(() => {
      if (matrixWarmupComplete || Date.now() - start > maxWait) {
        clearInterval(check);
        console.debug('[start] matrix warmup complete (or timeout). frames:', matrixFrameCount, 'warmup:', matrixWarmupComplete);
        // stop the warmup sound once warmup is done or timed out
        stopWarmupSound();
        resolve();
      }
    }, 100);
  });
  try {
    await showNumbersStepByStep(seedInput);
    console.debug('[start] showNumbersStepByStep completed');
  } catch (err) {
    console.error('[start] Error during showNumbersStepByStep:', err);
    throw err;
  }
  playMatrixTheme();
  document.getElementById('controls').style.display='none';
});
</script>
</body>
</html>
